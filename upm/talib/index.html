<!DOCTYPE html>
<html>
    <head>
        <title>AN EFFICIENT FINITE TREE AUTOMATA LIBRARY</title>
        <meta charset="utf-8">
        <link rel="stylesheet" type="text/css" href="../../static/style.css">
    </head>
    <body>
        <textarea id="source">

class: center, middle

# AN EFFICIENT FINITE TREE AUTOMATA LIBRARY
## Reading Group on Advanced Analysis of Non-Functional Global Properties
#### Kristoffer Dalby

---
# Agenda
- About
- Tree automata
  - 
- Exisiting Tree Automata libraries
  - Timbuk
  - MONA
  - Minor libraries
- Analysis
  - Abstract Regular Tree Model Checking
  - Requirements

---
# Agenda (2)
- Design
  - Representation
  - Operations on MTBDDs
  - Transducers
- Implementation
  - MTBDD Package
  - Object-Oriented Design
- Evaluation
  - Language Union
  - Language Intersection
  - Simulation Reduction
- Conclusion
- libvata

---
# About

- Master thesis for BRNO University of Technology
- Written by Ondřej Lengál


> The aim of this work is to design an efficient library that would be suitable for sophisticated tree model checking techniques while being flexible enough to be used even for methods which have not yet been developed.

.img50r[
   ![BRNO University of Technology](./img/brno.svg)
]

---
# Tree Automata

---
# Exisiting Tree Automata libraries
- Timbuk
- MONA
- Minor libraries

.img50r[
    ![Packaging](./img/packaging.svg)
]
---
# Timbuk

- Collection of tools for Term Rewriting Systems and Tree Automata
- Version 3.1 is latest (2.2 is the latest with TA)
- Written i OCaml by IRISA
- The code is open source (GNU LGPL v2)
- Tree automatons are implemented as tuple of lists

![Timbuk](./img/timbuk.svg)

???
- IRISA is a French research insitute that focuses on computer science and informatics.
- 2.2 Version is patched by Ondreij to run a newer OCaml version.
- The code is open source, and the author states that he studied the implementation.
- The tuple consists of: 
  - a list of symbols (an alphabet)
  - a list of state operators
  - a list of states
  - a list of final states
  - a list of transitions
  - a list of prioritary transitions
- Timbuk implements the "standard" operations:
  - Intersection
  - Union
  - Language emptiness
  - deletion of inaccessible states
  - Determinisation
  - others
- Timbuk can construct a tree automaton directly from a given term rewriting system.

---
# MONA

- Solves decision procedures for WS1S and WS2S
- Tree automata is a part of their "secrets"
  - More accuretly, the representation
  - Introduces MTBDD
- Guided tree automaton
- Eager minimisation
- MONA only supports deterministic finite tree automata
- The code is open source (GNU GPLv2)
- Written in C/C++ by BRICS/Aarhus University

.img50r[
    ![Tree](./img/tree.svg)
]

???
- WS1S (Weak monadic Second-order theory of 1 successor)
- WS2S (Weak monadic Second-order theory of 2 successors)
- MONA is heavily optimized of the years, and a co-author claims that MONA is tuned to give the "best" performance.
- MTBDD will be discussed more indept in the design part.
- Guided tree automaton helps tackle state space blow-up.
  - Bottom-up tree automate often suffer from the lack of position information in the tree.
  - Guided tree automaton provides a guide, an additional top-down TA that labels tree nodes with state spaces (aware of position).
  - This is done before the automaton startes working.
- Eager minimisation
  - When the automaton is modified, a Myhill-Nerode minimisation is performed
    - Myhill-Nerode: TODO
  - Yielded unexpected good results.
  - MONA uses DAGs for representations instead of trees to representate formulae.
- AT&T is also apart of the collaboration

---
# Minor libraries

- Lethal
  - Written in Java
  - Naive implementation with focus on education
  - Supports standard operations
  - Only library that implements tree transducers and hedge automata
- Binary Tree Automata Library
  - Written in Caml
  - Implements basic functions
  - Similar to Timbuk
  - Uses hash tables to represent transition tables

???
- Tree tranducers: TODO 
- Hedge automata: TODO

---
# Analysis
## Abstract Regular Tree Model Checking

Regular tree model checking: 
τ∗ (L(Init)) ∩ L(Bad) = ∅

- Abstract regular tree model checking
- Abstraction based on languages of finite height
- Abstraction based on predicate languages


???
- Where _Init_ is a tree automaton denoting the set of initial states of the system.
- Where _Bad_ is a tree automaton expressing the set of states violating the safety properties of the system.
- Where τ is a linear tree transducer representing the transition relation of the system.

- Abstract RTMC is a acceleration technique based on the _abstract-check-refine_ paradigm
- Abstraction based on languages of finite height, defines two states of a tree automaton as equivalent if their languages up to a given height n are identical. Similar to Myhill-Nerode.
- Abstraction based on predicate languages defines two states of a tree automaton equivalent if their languages have a nonempty intersection with exactly the same subset of languages represented by tree automata from P.

---
# Analysis (2)
## Requirements

- Create finite tree automaton denoting the:
  - Union
  - Intersection
  - Complement
- Determinisation of a finite tree automaton
- Minimasation of a finite tree automaton
- Reducing the size of a nondeterministic finite tree automaton
- Determining inclusion of languages of given finite automata
- Tree transducers in structure-perserving form
- The ability to efficiently traverse all states in order

???
- creating a finite tree automaton denoting the union of languages of given finite tree automata
- creating a finite tree automaton denoting the intersection of languages of given finite tree automata
- creating a finite tree automaton denoting the complement of the language of a given finite tree automaton
- Deterministaion: 
- Minimasation: 
- Reducing without Determinisation
- Determining inclusion while avoiding determinisation of any automaton.


---
# Design

---
# Representation

.img50c[
    ![Representation of shared MTBDD](./img/representation_shared_mtbdd.svg)
]

---
# Operations on MTBDDs (Union)

.img80c[
    ![Language union](./img/transition_union.svg)
]

---
# Operations on MTBDDs (Intersection)

.img80c[
    ![Language intersection](./img/transition_intersection.svg)
]
---
# Performing tranduction step

.img80c[
    ![Performing transduction step](./img/transduction_step.svg)
]

---
# Transducer composition

.img60c[
    ![Transducer composition](./img/transduction_composition.svg)
]

---
# Implementation

---
# MTBDD Package

.img50c[
    ![CUDD wrapper for MTBDD](./img/cudd_wrapper.svg)
]

---
# Object-Oriented Design

![Binding of policy classes](./img/binding_policy.svg)

---
# MTBDD Wrapper

![Cudd interface](./img/cudd_interface.svg)

---
# Tree Automaton
- Class

---
# Automaton import

.img80c[
    ![TABuildingDirector](./img/ta_building.svg)
]

---
# Automaton export

.img30c[
    ![Graphical representation of tree automaton](./img/ta_graphical.svg)
]


---
# Evaluation
- Libraries
  - libSFTA  
  - Timbuk
  - SA
- Benchmarking
  - Language operations (Union, Intersection)
  - Simulation Reduction

???
Timbuk is used in the tests with language opreations.
SA is used in the test with downward simulation.

---
# Language Union

| Automata 	|       	| Timbuk   	| libSFTA 	|
|----------	|-------	|----------	|---------	|
| A0053    	| A0054 	| 1.982s   	| 0.0005s 	|
| A0080    	| A0082 	| 37.645s  	| 0.0007s 	|
| A0080    	| A0111 	| 37.645s  	| 0.0008s 	|
| A0053    	| A0246 	| 414.104s 	| 0.0010s 	|
| A0080    	| A0246 	| 533.678s 	| 0.0012s 	|
| A0082    	| A0246 	| 542.069s 	| 0.0012s 	|

![Benchmark Union](./img/bench_union.svg)

---
# Language Intersection

| Automata 	|       	| Timbuk 	| libSFTA 	|
|----------	|-------	|--------	|---------	|
| A0053    	| A0054 	| 0.076s 	| 0.057s  	|
| A0053    	| A0246 	| 0.609s 	| 0.617s  	|
| A0080    	| A0082 	| 1.862s 	| 1.675s  	|
| A0080    	| A0111 	| 2.483s 	| 3.765s  	|
| A0080    	| A0246 	| 6.062s 	| 18.320s 	|
| A0082    	| A0246 	| 7.503s 	| 19.355s 	|

![Benchmark Intersection](./img/bench_intersect.svg)

---
# Simulation Reduction (State set size)

| Automaton 	| States 	| Transitions 	| SA    	| libSFTA 	|
|-----------	|--------	|-------------	|-------	|---------	|
| A0053     	| 53     	| 159         	| 0.04s 	| 24.6s   	|
| A0054     	| 54     	| 241         	| 0.04s 	| 29.3s   	|
| A0063     	| 63     	| 571         	| 0.10s 	| 55.2s   	|
| A0070     	| 70     	| 622         	| 0.07s 	| 71.5s   	|
| A0080     	| 80     	| 672         	| 0.11s 	| 274.4s  	|
| A0082     	| 82     	| 713         	| 0.09s 	| 331.5s  	|
| A0089     	| 89     	| 1006        	| 0.11s 	| 226.1s  	|

.img80c[
    ![Benchmark reduction of set size](./img/bench_reduction_set_size.svg)
]

---
# Simulation Reduction (Alphabet size)

| Symbols 	| StatesSA 	| libSFTA 	|
|---------	|----------	|---------	|
| 1337    	| 0.06s    	| 0.0033s 	|
| 3525    	| 0.14s    	| 0.0051s 	|
| 7067    	| 0.26s    	| 0.0054s 	|
| 15136   	| 0.69s    	| 0.0054s 	|
| 31235   	| 2.09s    	| 0.0031s 	|
| 65503   	| 8.86s    	| 0.0040s 	|
| 130023  	| 48.40s   	| 0.0045s 	|

.img80c[
   ![Benchmark reduction of alphabet](./img/bench_reduction_alphabet.svg)
]
---
# Conclusion

---
# libvata (VATA)
- Continuation of the research
- Implements optimized MTBDD
- Code is rewritten and optimized
- There exists example code


- [Source code](https://github.com/ondrik/libvata)
- [Web page](http://www.fit.vutbr.cz/research/groups/verifit/tools/libvata/)
- [Paper](http://link.springer.com/chapter/10.1007/978-3-642-28756-5_7)

---

# Questions?

---
# Links

Presentation: [kradalby.no/presentations/upm/talib](https://kradalby.no/presentations/upm/talib/index.html)
Github: [github.com/kradalby/presentations](https://github.com/kradalby/presentations/blob/master/upm/talib/index.html)
Paper: [An Efficient Finite Tree Automata Library](http://arxiv.org/abs/1204.3240)

---
# Image credits

- Slide # Exisiting Tree Automata libraries
  - Packaging by Richard Slater from the Noun Project
- Slide # MONA
  - Tree by Richard Nixon from the Noun Project
        </textarea>
        <script src="../../static/remark-latest.min.js">
        </script>
        <script>
            var slideshow = remark.create({
              highlightLanguage: 'c',
              highlightStyle: 'monokai'
            });
        </script>
    </body>
</html>

